// Generated by Reo 1.0

#[allow(unused_imports)]
use maplit::{hashmap, hashset};

pub use reo_rs::*;

#[allow(unused_imports)]
use reo_rs::{
    building::{NameDef::*, *},
    Instruction::*,
    Term::*,
};
#[no_mangle]
pub extern "C" fn reors_generated_proto_create() -> CProtoHandle {
    reo_rs::to_c_proto(proto_protocol1_build_rust::<isize,isize>())
}

pub fn proto_protocol1_build_rust<T0, T1>(
) -> ProtoHandle
where
    T0: 'static + Send + Sync + Sized + core::str::FromStr,
    T1: 'static + Send + Sync + Sized,
{
    let name_defs = hashmap!{
        "p_1" => Port { is_putter:  true, type_info: TypeInfo::of::<T1>() },
        "x_2" => Port { is_putter: false, type_info: TypeInfo::of::<T1>() },
        "x_1" => Port { is_putter: false, type_info: TypeInfo::of::<T1>() },
        "x_4" => Port { is_putter: false, type_info: TypeInfo::of::<T1>() },
        "x_3" => Port { is_putter: false, type_info: TypeInfo::of::<T1>() },
        "m1" => Mem(TypeInfo::of::<T1>()),
        "m2" => Mem(TypeInfo::of::<T0>()),
        "m3" => Mem(TypeInfo::of::<T0>()),
        "m4" => Mem(TypeInfo::of::<T0>()),
        "m5" => Mem(TypeInfo::of::<T0>()),
    };
    let rules = vec![
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"x_3", },
                full_mem: hashset! {"m1", "m3", },
                empty_mem: hashset! {"m4", },
            },
            ins: vec![
            ],
            output: hashmap!{
                "m1" => (false, hashset!{"x_3", }),
                "m3" => (false, hashset!{"m4", }),
            }
        },
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"x_4", },
                full_mem: hashset! {"m1", "m4", },
                empty_mem: hashset! {"m5", },
            },
            ins: vec![
            ],
            output: hashmap!{
                "m1" => (false, hashset!{"x_4", }),
                "m4" => (false, hashset!{"m5", }),
            }
        },
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"p_1", },
                full_mem: hashset! {},
                empty_mem: hashset! {"m1", },
            },
            ins: vec![
            ],
            output: hashmap!{
                "p_1" => (false, hashset!{"m1", }),
            }
        },
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"x_2", },
                full_mem: hashset! {"m1", "m2", },
                empty_mem: hashset! {"m3", },
            },
            ins: vec![
            ],
            output: hashmap!{
                "m1" => (false, hashset!{"x_2", }),
                "m2" => (false, hashset!{"m3", }),
            }
        },
        RuleDef {
            state_guard: StatePredicate {
                ready_ports: hashset! {"x_1", },
                full_mem: hashset! {"m1", "m5", },
                empty_mem: hashset! {"m2", },
            },
            ins: vec![
            ],
            output: hashmap!{
                "m1" => (false, hashset!{"x_1", }),
                "m5" => (false, hashset!{"m2", }),
            }
        },
    ];
    let mem_init = MemInitial::default()
        .with("m5", T0::from_str_expect("0"));
    ProtoDef {
        name_defs,
        rules
    }.build(mem_init).expect("Oh no! Reo failed to build!")
}

