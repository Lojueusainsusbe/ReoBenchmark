\section{Conclusion}
The C Alternator seems comparable to the Reo implementation at size 4, the difference present seems negligible. Our C Early Out Async Sequencer starts out slightly slower but eventually performs better than the Reo version. It should be noted that the results from the Alternator and Early Async Out Sequencer in graph \{tab:res} are probably not representative of their true performance due to the limited amount of data.\\\\
%
We can be more confident in the results from the Sequencer and Early Async Replicator in graph \ref{grf:res2}. \\
Our C Sequencer starts out slightly worse than the Reo implementation, but clearly overtakes Reo after the size goes increases. From our, admittedly limited, number of data points we see that out C implementation scales linearly up until 512 consumers. Whereas the Reo implementation seems to enter an exponential growth of runtime in relation to the amount of consumers.\\
The Reo Early Async Replicator is clearly beaten by the C implementation. While both seem to have a near linear scaling, the C implementation scales much better.\\\\
%
It can also be seen that Reo outperforms our C implementations at very low sizes quite consistently. Only the Reo Alternator is slower than the C version at size 4, where there is no other data available, and even then its is comparable. As the size increases, Reo seems to lose its advantage and scales more poorly than C. C overtakes it at different points, depending on the specific protocol, but is eventually better than Reo in all of our tests.

\section{Further Research}
The completion of our planned tests and the benchmarking of additional protocols are obvious candidates for future research. The scope of this benchmark is already limited and has been limited further due to problems with the compiler. If the compiler permits more extensive testing, this could be of interest in the future.\\\\
%
The Sequencer and Early Async Replicator are our more successful experiments and could prompt further research.
There is a clear separation in the type of scaling of the different Sequencer implementations. Reo has the upper hand at first, seemingly optimizing better at lower sizes, but at some point its long term scaling is worse. Running more experiments at finer intervals could more accurately depict the scaling of both implementations and reveal exactly at what point C overtakes Reo. In addition to finer intervals, more experiments at greater sizes could reveal how well the scaling of both the Reo and C implementations holds up as the given size grows.
