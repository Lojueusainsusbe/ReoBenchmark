\section{Conclusion}
The C Alternator seems comparable to the Reo implementation. The difference present at size 4 is negligable. Our C Early Out Async Sequencer starts out slightly slower but is starting to perform faster than the Reo version. It can obviously be noted that the results from the Alternator and Early Async Out Sequencer in graph \ref{grf:res} are not reliable due to the limited amount of data.\\\\
%
We are able to be speak more surely to the results of the Sequencer and Early Async Replicator in graph \ref{grf:res2}. \\
Our C Sequencer starts out slightly worse than the Reo implementation, but clearly overtakes Reo after the size goes into the hundreds. From our, admittedly limited number of, data points we see that out C implementation scales linearly up until 512 consumers. Whereas the Reo implementation seems to enter an exponential growth of runtime in relation to the amount of consumers.\\
The Reo Early Async Replicator is clearly beaten by the C implementation. While both seem to have a near linear scaling, the C implementation scales much better by several orders of magnitude.\\\\
%
It can also be seen that Reo outperforms our C implementations at very low sizes quite consistently. Only the Reo Alternator is slower that the C version at size 4, where there is no other data available, and even then its is comparable. As the size increases, Reo seems to lose its advantage and scales more poorly than C. C overtakes it at different points, depending on the specific protocol, but is eventually better than Reo in all of our tests.

\section{Further Research}
The completion of our planned tests and the benchmarking of additional protocols are obvious candidates for future research. The scope of this benchmark is already limited and has been limited further due to problems with the compiler. If the compiler permits more extensive testing, this could be of interest in the future.\\\\
%
Our more succesfull experiments are also of some interest and could prompt further research.\\
There is a clear seperation in the type of scaling of the different Sequencer implementations. Reo has the upperhand at first, but at some point its scaling worsens. Running more experiments at finer intervals could more accurately depict the scaling of both implementations and reveal at what point C overtakes Reo. More experiments at greater sizes can reveal how well the scaling of both the Reo and C implementations holds up as the given size grows.
