\section{Introduction}
Many programs are comprised of different parallel processes that need to synchronize, communicate, or pass messages. Such behavior can be expressed as a protocol defining the data flow between different processes. Current implementations of such behavior use near archaic programming paradigms such as mutexes, semaphores, monitors, etc. Such implementations are generally implemented on a low level within the code of the components, making modification or verifying the higher level protocol disproportionately difficult.\\
The Reo Coordination Language \cite{reo} allows the specification of a high level protocol separate from the implementation of different processes. This allows easy modification of protocols and allows them to be ported to different applications by simply exchanging the corresponding processes. \\\\
%
Using the current build of the Reo Compiler \cite{reo:git} we will build several circuits and benchmark them. These will be compared to a similar C\texttt{++} implementation that implements the same circuits.\\
We will provide a specification of the protocols and describe their behavior, which we will follow with a description of our experiments and the used hardware. Lastly our gathered results will be provided and discussed.
